1 
 UNIVERSITATEA BABEÅ -BOLYAI  
FACULTATEA DE MATEMATICÄ‚ ÅI INFORMATICÄ‚  
 
 
Concurs de admitere â€“ 15 septembrie 2022 
Proba scrisÄƒ la InformaticÄƒ  
 
NOTÄ‚ IMPORTANTÄ‚:  
Ãn lipsa altor precizÄƒri, presupuneÈ›i cÄƒ toate opera È›iile aritmetice se efectueazÄƒ pe tipuri de date nelimitate 
(nu existÄƒ overflow  / underflow ). 
De asemenea, numerotarea indicilor tuturor È™irurilor /vectorilor  Ã®ncepe de la 1.  
 
1. Se considerÄƒ algoritmul decide(n, x) , unde n  este numÄƒr natural (1 â‰¤ n â‰¤ 10000) , iar x este un 
vector cu n  elemente numere Ã®ntregi (x[1], x[2], ..., x [n], -100 â‰¤ x[i] â‰¤ 100, pentru i = 1, 2, ..., n ): 
Algorithm decide(n, x):  
    b â† True 
    i â† 1 
    While b = True AND i < n execute 
        If  x[i] < x[i + 1] then  
            b â† True 
        else  
            b â† False     
        EndIf         
        i â† i + 1 
    EndWhile  
    return  b 
EndAlgorithm  
 
Pentru care din urmÄƒtoarele situaÈ›ii algoritmul returneazÄƒ True ? 
A. DacÄƒ vectorul x este format din valorile 1, 2, 3, â€¦, 10.  
B. DacÄƒ vectorul x este strict crescÄƒtor.  
C. DacÄƒ vectorul x nu are elemente negative.  
D. DacÄƒ vectorul x are elemente pozitive situate Ã®naintea celor negative.  
 
2. Se considerÄƒ un numÄƒr natural fÄƒrÄƒ cifre egale cu zero, dat prin È™irul a (a[1], a[2], ..., a[n]) Ã®n care se 
aflÄƒ cele n cifre ale sale (1 â‰¤ n â‰¤ 10 la momentul apelului iniÈ›ial). PrecizaÈ›i care din tre urmÄƒtorii 
algoritmi returneazÄƒ True  dacÄƒ un numÄƒr dat sub aceastÄƒ formÄƒ este palindrom È™i False  Ã®n caz contrar. 
Un numÄƒr este palindrom dacÄƒ citit de la stÃ¢nga la dreapta are aceeaÈ™i valoare ca atunci cÃ¢nd se citeÈ™te 
de la dreapta la stÃ¢nga.  
A.  
Algorithm palindrom_1(a, n):  
    i â† 1  
    j â† n  
    k â† True  
    While (i â‰¤ j) AND (k = True) execute  
        If  a[i] = a[j] then 
            i â† i + 1  
            j â† j - 1 
        else  
            k â† False  
        EndIf  
    EndWhile  
    return  k 
EndAlgorithm  B.  
Algorithm translatare(a, n):  
    For i = 1, n -  1 execute  
        a[i] â† a[i + 1]  
    EndFor  
EndAlgorithm  
  
Algorithm palindrom_2(a, n):  
    j â† n  
    If (j = 0) OR (j = 1) then  
        return  True 
    EndIf  
    If a[1] = a[j] then  
        translatare(a, n)  
        return  palindrom_2(a, n - 2) 
    EndIf  
    return  False 
EndAlgorithm  2 
 C.  
Algorithm palindrom_3(a, n):  
    i â† n  
    j â† 1  
    k â† True  
    sum1 â† 0  
    sum2 â† 0  
    While (i > n DIV 2) AND (j â‰¤ n DIV  2)  
execute  
        sum1 â† sum1 + a[i]  
        sum2 â† sum2 + a[j]  
        i â† i - 1 
        j â† j + 1  
    EndWhile  
    If sum1 = sum2 then  
        k â† True  
    else  
        k â† False  
    EndIf  
    return  k 
EndAlgorithm  D.  
Algorithm palindrom_4(a, n):  
    i â† 1  
    j â† n  
    k â† True  
    While (i â‰¤ j) AND (k = True) execute  
        If  (a[i] = a[j]) AND (i MOD 2 = 0)  
AND (j MOD 2 = 0) then 
            i â† i + 1  
            j â† j - 1 
        else  
            k â† False  
        EndIf  
    EndWhile  
    return  k 
EndAlgorithm  
 
3. Se considerÄƒ algoritmul F(n), unde n  este numÄƒr natural (1 â‰¤ n â‰¤ 109). 
 
Algorithm  F(n): 
    If n < 10 then 
        return  n 
    EndIf  
    u â† n MOD 10 
    p â† F(n DIV 10) 
    If u MOD 5 â‰¤ p MOD 5 then  
        return  u 
    EndIf  
    return  p 
EndAlgorithm  
 
PrecizaÈ›i care din tre urmÄƒtoarele afirmaÈ›ii sunt corecte:  
A. DacÄƒ n  = 812376, valoarea returnatÄƒ de algoritm este 6.  
B. DacÄƒ n  = 8237631, valoarea returnatÄƒ de algoritm este 1.  
C. DacÄƒ n  = 4868, valoarea returnatÄƒ de algoritm este 8.  
D. DacÄƒ n  = 51, valoarea returnatÄƒ de algoritm este 0.  
 
4. Se considerÄƒ algoritmul f(n), unde parametrul n  este numÄƒr natural (1 â‰¤ n  â‰¤ 109). 
Algorithm f(n):  
    v â† 0; z â† 0;  
    For c â† 0, 9 execute   
        x â† n  
        k â† 0  
        While x > 0 execute  
            If  x MOD 10 = c then  
                k â† k + 1  
            EndIf  
            x â† x DIV 10  
        EndWhile  
        If  k > v then  
            v â† k  
            z â† c  
        EndIf  
    EndFor   
    return  z  
EndAlgorithm  3 
 Care dintre afirmaÈ›iile urmÄƒtoare sunt adevÄƒrate ? 
 
A. Algoritmul returneazÄƒ numÄƒrul cifrelor numÄƒrului n . 
B. Algoritmul returneazÄƒ numÄƒr ul de apariÈ›ii ale cifrei cu valoarea cea mai mare Ã®n numÄƒrul n . 
C. Algoritmul returneazÄƒ una dintre cifrele cu cel mai mare numÄƒr de apariÈ›ii Ã®n  numÄƒrul n. 
D. Algoritmul returneazÄƒ numÄƒrul cifrelor avÃ¢nd cel mai mare numÄƒr de apariÈ›ii Ã®n  numÄƒrul n . 
 
 
5. Care dintre urmÄƒtorii algoritmi afiÈ™eazÄƒ reprezentarea binarÄƒ a numÄƒrului natural x dat ca parametru 
(0 < x â‰¤  109 la momentul apelului iniÈ›ial)?  
A.  
Algorithm imp(x):  
    If x = 0 then  
        r â† x MOD 2  
        imp(x DIV 2)  
        write r   
    EndIf  
EndAlgorithm  
C.  
Algorithm imp(x):  
    If x = 0 then  
        r â† x DIV 2  
        imp(x DIV 2)  
        write r   
    EndIf  
EndAlgorithm  B.  
Algorithm imp(x):  
    If x â‰  0 then  
        r â† x MOD 2  
        imp(x DIV 2)  
        write r   
    EndIf  
EndAlgorithm  
D.  
Algorithm imp(x):  
    If x â‰  0 then  
        r â† x MOD 2  
        imp(x)  
        write r   
    EndIf  
EndAlgorithm  
 
6. Care dintre urmÄƒtoarele afirmaÈ›ii referitoare la variantele subiectului 5 sunt adevÄƒrate?  
 
A. Ãn timpul execuÈ›iei algoritmului de la varianta A nu se afiÈ™eazÄƒ nimic.  
B. Algoritmul de la varianta B nu se va apela recursiv pentru nicio valoare validÄƒ a parametrului x  
C. Algoritmul de la varianta C ar fi corect, dacÄƒ am schimba "=" cu "â‰ "  
D. Algoritmul de la varianta D ar fi corect, dacÄƒ am schimba "imp(x) " cu "imp(x DIV 2)". 
 
7. Se considerÄƒ numerele Ã®ntregi a È™i b (-1000 â‰¤ a, b  â‰¤ 1000) È™i expresia: NOT ((a > 0) AND (b > 0)) . 
 
Care dintre urmÄƒtoarele expresii sunt echivalente cu expresia datÄƒ mai sus:  
A. (NOT (a < 0)) AND (NOT (b < 0))  
B. (a â‰¤ 0) AND (b â‰¤ 0) 
C. (NOT (a > 0)) OR (NOT (b > 0))  
D. NOT ((a > 0) OR  (b < 0))  
 
8. Se considerÄƒ algoritmul s(n), unde n este numÄƒr natural (2 â‰¤ n â‰¤ 10). Operatorul / reprezintÄƒ 
Ã®mpÄƒrÈ›irea realÄƒ (ex. 3 / 2 = 1,5).  
Algorithm  s(n):  
    p â† 1 
    x â† 0 
    For k = 0, n - 1 execute  
        p â† p * (k + 1)  
        x â† x + 1 / p  
    EndFor  
    return  x 
EndAlgorithm  PrecizaÈ›i care dintre urmÄƒtoarele sume este returnatÄƒ 
de algoritmul dat. 
 
A. âˆ‘1
ğ‘˜ğ‘˜!ğ‘›ğ‘›
ğ‘˜ğ‘˜=0   
B. âˆ‘1
ğ‘˜ğ‘˜ğ‘›ğ‘›ğ‘˜ğ‘˜=0 
C. âˆ‘1
ğ‘˜ğ‘˜!ğ‘›ğ‘›âˆ’1ğ‘˜ğ‘˜=0 
D. âˆ‘1
ğ‘˜ğ‘˜!ğ‘›ğ‘›ğ‘˜ğ‘˜=1  
  4 
 9. Se considerÄƒ algoritmul ceFace(n) , unde n este numÄƒr natural pozitiv (1 â‰¤  n â‰¤ 10000).  
Algorithm ceFace(n):  
    m â† 0  
    p â† 10  
    While p < n execute 
        r â† n MOD p  
        m â† m + r  
        p â† p * 10  
    EndWhile  
    return m 
EndAlgorithm  PrecizaÈ›i care dintre urmÄƒtoarele afirmaÈ›ii sunt adevÄƒrate:  
 
A. Pentru n  = 125 algoritmul returneazÄƒ valoarea 521.  
B. Algoritmul ceFace(n)  returneazÄƒ oglinditul 
numÄƒrului n . 
C. Pentru n  = 125 algoritmul returneazÄƒ valoarea 155.  
D. Pentru n  = 340 algoritmul returneazÄƒ valoarea 40.  
 
10. Se considerÄƒ algoritmul f(v, n) , unde n este numÄƒr natural nenul (1 â‰¤ n â‰¤ 10000) È™i v este un vector 
cu n numere naturale pozitive ( v[1], v[2], ..., v[n]). Presupunem cÄƒ algoritmul  prim(d)  returneazÄƒ True 
dacÄƒ d (numÄƒr natural) este prim È™i False  Ã®n caz contrar. 
 
Algorithm f(v, n):  
    x â† 1  
    a â† 0  
    For i â† 1, n execute   
        For d â† 2, (v[i] DIV 2) execute  
            If (prim(d) = True) AND (v[i] MOD d = 0) then  
                x â† x * d  
            EndIf  
        EndFor   
    EndFor   
    For d â† 2, (x DIV 2) execute  
        If (x MOD d = 0) AND (prim(d) = True) then  
            a â† a + 1  
        EndIf  
    EndFor  
    return a  
EndAlgorithm  
 
 
PrecizaÈ›i care dintre urmÄƒtoarele afirmaÈ›ii sunt adevÄƒrate:  
 
A. Algoritmul returneazÄƒ numÄƒrul divizorilor proprii primi distincÈ›i ai tuturor numerelor din 
vectorul v. 
B. Algoritmul returneazÄƒ produsul divizorilor primi ai numerelor din vectorul v . 
C. Algoritmul returneazÄƒ numÄƒrul numerelor prime din vectorul v . 
D. Algoritmul returneazÄƒ numÄƒrul total al tuturor divizorilor numerelor din vectorul v . 
  5 
 11. Se considerÄƒ algoritmul f(n), unde n  este numÄƒr natural ( 0 < n  â‰¤ 109 la momentul apelului) . 
Variabila localÄƒ v este un vector.  
Algorithm f(n):  
    m â† 0  
    While n > 0 execute   
        m â† m + 1 
        v[m] â† n MOD 10 
        n â† n DIV 10  
    EndWhile   
    x â† 0  
    mx â† 0  
    While mx > -1 execute  
        x â† x * 10 + mx  
        mx â† -1  
        j â† 1  
        For i = 1, m execute  
            If v[i] > mx then  
                j â† i  
                mx â† v[i]  
            EndIf  
        EndFor   
        v[j] â† -1  
    EndWhile  
    return x   
EndAlgorithm  
 
PrecizaÈ›i care dintre urmÄƒtoarele afirmaÈ›ii sunt adevÄƒrate:  
A. Algoritmul returneazÄƒ cel mai mare numÄƒr care se poate obÈ›ine folosind cifrele lui n . 
B. Algoritmul returneazÄƒ cea mai mare putere a lui 10 care divide numÄƒrul n . 
C. Algoritmul returneazÄƒ prima cifrÄƒ din stÃ¢nga a numÄƒrului n . 
D. Algoritmul returneazÄƒ suma cifrelor numÄƒrului n . 
 
12. Se considerÄƒ algoritmul f(n), unde parametrul n  este numÄƒr natural (1 â‰¤ n â‰¤ 10002 la momentul 
apelului).  
 Algorithm  f(n):  
    z â† 0; p â† 1;  
    While n â‰  0 execute  
        c â† n MOD 10  
        n â† n DIV 10  
        If  c MOD 3 = 0 then  
            z â† z + p * (9 â€“  c)  
            p â† p * 10  
        EndIf  
    EndWhile  
    return  z  
EndAlgorithm  
 
Care este valoarea returnatÄƒ dacÄƒ algoritmul se apeleazÄƒ pentru n = 103456?  
A. 639  B. 963   C. 693   D. 369 
 
13. Se considerÄƒ algoritmul f(n) dat Ã®n enunÈ›ul  subiectul ui 12, dar  acum parametrul n este numÄƒr 
natural cu douÄƒ cifre (10 â‰¤ n â‰¤ 99 la momentul apelului) . 
 
Care dintre urmÄƒtoarele variante conÈ›in doar numere pentru care algoritmul returneazÄƒ valoarea 3?  
 
A. 61, 65, 67  
B. 62, 66, 68  
C. 16, 56, 76  
D. 26, 66, 86  6 
 14. Se dÄƒ algoritmul ceFace(a, b) , unde a È™ i b sunt numere naturale pozitive (1 â‰¤  a, b â‰¤ 10000).   
Algorithm ceFace(a, b):  
    For i â† 2, a, 2 execute   
        If a MOD i = 0 then 
            If  b MOD i = 0 then  
                Write i  
                Write new line  
            EndIf  
        EndIf  
    EndFor  
EndAlgorithm  
 
DacÄƒ a = 600, precizaÈ›i pentru c are valori ale lui b se afiÈ™eazÄƒ 4 numere Ã®n urma executÄƒrii algoritmului 
ceFace(a, b):  
 
A.  b = 20   B.  b = 50   C.  b = 12   D. b = 90  
 
15. ConsiderÃ¢nd algoritmul de la subiectul 14, p recizaÈ›i care dintre urmÄƒtoarele afirmaÈ›ii sunt adevÄƒrate:  
A. Algoritmul afiÈ™eazÄƒ divizorii comuni ai numerelor a È™i b. 
B. Algoritmul afiÈ™eazÄƒ divizorii proprii comuni ai numerelor a È™i b. 
C. Algoritmul afiÈ™eazÄƒ divizorii impari comuni ai numerelor a È™i b. 
D. Algoritmul afiÈ™eazÄƒ divizorii pari comuni ai numerelor a È™i b. 
 
16. Fie un program care genereazÄƒ, Ã®n ordine crescÄƒtoare, toate numerele naturale de exact 5 cifre 
distincte care se pot forma cu cifrele 2, 3, 4, 5, 6.  
 
PrecizaÈ›i numÄƒrul generat imediat Ã®nainte È™i numÄƒrul generat imediat dupÄƒ secvenÈ›a urmÄƒtoare:  
34256, 34265, 34526, 34562. 
 
A. 32645 È™i 34625   B. 32654 È™i 34655   C. 32654 È™i 34625   D. 32645 È™i 34655  
 
17. Fie È™irul x = (1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 
6, 6, 6, 6, 6, 6, 6, 6, 7, ...), care se continuÄƒ conform regulii care se poate observa din elementele 
enumerate.  
 
ConsiderÃ¢nd cÄƒ  primul element din  È™ir este pe poziÈ›ia 1,  Ã®n care din tre urmÄƒtoarele subsecvenÈ›e va apÄƒrea 
doar valoarea 11? 
 
A.  x[100], ..., x [109]   B.  x[113], ..., x [120]   C.  x[140], ..., x [152]   D.  x[123], ..., x [132]  
 
18. CÃ¢te din primele 100 de elemente ale È™irului x descris Ã®n subiectul 17  sunt numere prime?  
 
A. 4   B. 34   C. 36   D. 30 
 
19. Se considerÄƒ numerele naturale a È™i n (1 â‰¤ a, n â‰¤ 1000) , vectorul V cu n elemente numere naturale 
(V[1], V [2], ..., V [n]) È™i algoritmii one(a, n, V)  È™i two(a, n, V) :   
 
Algorithm  one(a, n, V):  
    p â† 1; i â† 1;  
    While (i â‰¤ n) AND (a > V[p]) execute  
        p â† p + 1  
        i â† i + 1  
    EndWhile  
    return  p  
EndAlgorithm  Algorithm  two(a, n, V):  
    p â† 1; i â† 1;  
    While i â‰¤ n execute   
        If  a > V[i] then   
            p â† p + 1  
        EndIf  
        i â† i + 1   
    EndWhile  
    return  p  
EndAlgorithm   
Ce proprietate poate avea vectorul V, astfel Ã®ncÃ¢t, pentru orice n  È™i V cu proprietatea datÄƒ, cei doi 
algoritmi sÄƒ returneze valori egale pentru orice valoare a lui a?  7 
 A. Ãn vectorul V  toate elementele sunt egale.  
B. Ãn vectorul V  toate elementele sunt distincte È™i sortate crescÄƒtor.  
C. Ãn vectorul V  toate elementele sunt distincte È™i sortate descrescÄƒtor.  
D. Ãn vectorul V  elementele sunt sortate crescÄƒtor, dar nu sunt neapÄƒrat distincte.  
 
20. Se considerÄƒ algoritmul suma(n)  unde n este numÄƒr natural (0 < n â‰¤ 10000 la momentul apelului 
iniÈ›ial).   
Algorithm suma(n):  
    If n = 0 then   
        return 0  
    else   
        return  suma(n - 1) + n DIV  (n + 1) + (n + 1) DIV n  
    EndIf  
EndAlgorithm  
 
Care dintre afirmaÈ›iile de mai jos NU sunt adevÄƒrate?  
A. Algoritmul returneazÄƒ valoarea n + 1 
B. Algoritmul calculeazÄƒ È™i returneazÄƒ suma divizorilor proprii ai lui n  
C. Apelul suma(1)  returneazÄƒ 2  
D. Algoritmul calculeazÄƒ È™i returneazÄƒ dublul pÄƒrÈ›ii Ã®ntregi a mediei aritmetice a primelor n 
numere naturale  
 
21. Fie  urmÄƒtorul algoritm, avÃ¢nd ca parametri de intrare numerele naturale a È™i b (0 â‰¤  a, b â‰¤ 10000 la 
momentul apelului iniÈ›ial):  
Algorithm ceFace(a, b):  
    While a * b â‰  0 execute 
        If  a > b then  
            return  ceFace(a MOD b, b)  
        else  
            return  ceFace(a, b MOD  a) 
        EndIf  
    EndWhile  
    return  a + b  
EndAlgorithm  
 
PrecizaÈ› i care dintre urmÄƒtoarele afirmaÈ›ii sunt adevÄƒrate:  
A. Algoritmul returneazÄƒ suma numerelor a È™i b. 
B. Algoritmul returneazÄƒ numÄƒrul nenul x Ã®n urma apelului ceFace(x, 0)  sau ceFace(0, x) , 
respectiv 0 pentru ceFace(0, 0) . 
C. Algoritmul returneazÄƒ cel mai mare divizor comun al numerelor a È™i b. 
D. Algoritmul returneazÄƒ  a la puterea b. 
 
22. Se considerÄƒ algoritmul afiÈ™are(n)  unde n  este numÄƒr natural (1 â‰¤ n â‰¤ 109): 
Algorithm afiÈ™are(n):  
    For i = 1, n â€“  1 execute 
        For j = i + 1, n  execute 
            If  (j â€“ i) < (n DIV 2) then 
                Write i, " ", j â€“  i 
                Write new line  
            else   
                If  (j â€“ i) â‰  (n DIV 2) then 
                    Write j â€“ i, " ", i  
                    Write new line  
                EndIf  
            EndIf  
        EndFor  
    EndFor  
EndAlgorithm  8 
 CÃ¢te perechi de numere se vor afiÈ™a Ã®n urma execuÈ›iei algoritmului pentru n  = 7?  
A. 21 
B. 15 
C. 11 
D. 17 
 
23. ConsiderÃ¢nd secvenÈ›a de cod de mai jos, determinaÈ›i de cÃ¢te ori se afiÈ™eazÄƒ È™irul de caractere UBB, 
È™tiind cÄƒ  n = 3k, unde k este numÄƒr natural (1 â‰¤ k â‰¤ 30)?  
j â† n 
While j > 1 execute  
    i â† 1  
    While i â‰¤ n execute  
        i â† 3 * i  
        Write 'UBB'  
    EndWhile  
    j â† j DIV 3 
EndWhile  A.  k2  
B. k * 3k 
C.  k * ( k+1) 
D.  3 * k  
 
 
24. Se dau urmÄƒtoarele secvenÈ›e de cod È™i numerele naturale i, j, a, b (1 < a, b â‰¤ 109).  
 
SecvenÈ›a 1 (S1)   
 
i â† 1  
While i â‰  b execute  
    j â† 1  
    While j â‰  a execute  
        Write '*' 
        j â† j + 1    
    EndWhile  
    i â† i + 1  
EndWhile   SecvenÈ›a 2 (S2)  
 
i â† 1  
While i â‰  a execute  
    j â† 1  
    While j â‰  b execute   
        Write '*' 
        j â† j + 1    
    EndWhile  
    i â† i + 1  
EndWhile   
 
Care dintre afirmaÈ›iile urmÄƒtoare sunt adevÄƒrate?  
 
A. NumÄƒrul de caractere afiÈ™ate de secvenÈ›a S1 este diferit faÈ›Äƒ de numÄƒrul de caractere afiÈ™ate de 
secvenÈ›a S2. 
B. Ambele secvenÈ›e au aceeaÈ™i complexitate timp.  
C. NumÄƒrul de caractere afiÈ™ate de secvenÈ›a S1 este ( a â€“ 1) * ( b â€“ 1).  
D. NumÄƒrul de caractere afiÈ™ate de secvenÈ›a S2 este a * b. 
 
25. Se considerÄƒ algoritmul ceFace(nr) , unde nr  este un numÄƒr natural (100 â‰¤  nr â‰¤ 2*109 la momentul 
apelului).  
Algorithm testProprietateNr(n):  
    If n â‰¤ 1 then  
        return  False  
    EndIf  
    d â† 2  
    While d * d â‰¤ n execute  
        If  n MOD d = 0 then  
            return  False  
        EndIf  
        d â† d + 1  
    EndWhile  
    return  True  
EndAlgorithm  Algorithm  ceFace(nr):  
    s â† 0  
    c1 â† nr MOD 10  
    nr â† nr DIV 10  
    c2 â† nr MOD 10  
    nr â† nr DIV 10 
    While nr â‰  0 execute  
        c3 â† nr MOD 10  
        t â† c3 * 100 + c2 * 10 + c1  
        If  testProprietateNr(t) then 
            s â† s + c1 + c2 + c3  
        EndIf  
        c1 â† c2  
        c2 â† c3  
        nr â† nr DIV 10  
    EndWhile  
    return  s  
EndAlgorithm  9 
  
PrecizaÈ›i valoarea pe care o returneazÄƒ algoritmul ceFace(nr)  pentru nr  = 1271211312?  
 
A.  31   B.  32   C.  33   D.  34 
 
26. Care dintre urmÄƒtorii algoritmi determinÄƒ corect È™i returneazÄƒ valoarea rÄƒdÄƒcinii pÄƒtrate a numÄƒrului 
natural n (0 < n < 105), rotunjit Ã®n jos la cel mai apropiat Ã®ntreg. Operatorul / reprezintÄƒ Ã®mpÄƒrÈ›irea realÄƒ 
(ex. 3 / 2 = 1,5).  
A.  
Algorithm radical_A(n):  
    x â† 0  
    z â† 1  
    While z â‰¤ n execute  
        x â† x + 1  
        z â† z + 2 * x  
        z â† z + 1  
    EndWhile  
    return  x  
EndAlgorithm  
C.  
//Algoritmul se apeleazÄƒ iniÈ›ial  
//Ã®n forma radical_C(n, n) 
Algorithm radical_C(n, x):   
    eps â† 0.001  
    y â† 0.5 * (x + n / x) 
    If x - y < eps then  
        //se returneazÄƒ partea  
        //Ã®ntreagÄƒ a lui x 
        return  [x]  
    EndIf  
    return  radical_C(n, y)  
EndAlgorithm  
 B.  
Algorithm radical_B(n):  
    s â† 1  
    d â† n DIV 2 
    While s < d execute  
        k â† (s + d) DIV  2 
        If  k * k â‰¥ n then  
            d â† k  
        else  
            s â† k + 1  
        EndIf  
    EndWhile  
    If s * s â‰¤ n then  
        return  s + 1  
    else  
        return  s - 1 
    EndIf  
EndAlgorithm  
D.  
Algorithm radical_D(n):  
    s â† 0  
    p â† 0  
    k â† 0  
    While k < n execute  
        k â† k + 3 + p  
        p â† p + 2  
        s â† s + 1  
    EndWhile  
    return  s 
EndAlgorithm  
 
27. È˜tiind cÄƒ x este numÄƒr natural, c are dintre urmÄƒtoarele expresii au valoarea True  dacÄƒ È™i numai 
dacÄƒ x este numÄƒr par care NU apar È›ine intervalului deschis  (10, 20)?  
 
A. NOT((x > 10) AND (x < 20)) AND (NOT (x MOD 2 = 1)) 
B. (x MOD 2 = 0) AND ((x < 10) OR  (x > 20))  
C. NOT(x MOD 2 = 1) AND ((x > 10) AND  (x < 20))  
D. NOT((x MOD 4 = 1) OR (x MOD 4 = 3) OR ((x > 10) AND (x < 20))) 
 
 
28. Se dÄƒ un È™ir  a de n numere naturale distincte ( a[1], a[2], â€¦, a[n], 2 â‰¤ n â‰¤ 1000) ordonate strict 
crescÄƒtor. Ãntr -un È™ir se numeÈ™te vÃ¢rf local  un numÄƒr cu proprietatea cÄƒ este strict mai mare decÃ¢t 
numÄƒrul de pe poziÈ›ia anterioarÄƒ, dar È™i decÃ¢t numÄƒrul de pe poziÈ›ia urmÄƒtoare. Primul È™i ultimul element din È™ir nu pot fi vÃ¢rfuri locale . Se doreÈ™te un algoritm  
rearanjare(a, n)  care rearanjeazÄƒ valorile din 
È™ir astfel Ã®ncÃ¢t È™irul sÄƒ aibÄƒ un numÄƒr maxim de vÃ¢rfuri locale È™i returneazÄƒ noul È™ir. Variabila localÄƒ b 
este un È™ir. Care dintre urmÄƒtor ii algoritmi sunt corec È›i? 
  10 
 A.  
Algorithm rearanjare(a, n):  
    i â† n  
    For p â† 2, n, 2 execute  
        b[p] â† a[i]  
        i â† i â€“ 1 
    EndFor  
    For p â† 1, n, 2 execute  
        b[p] â† a[i]  
        i â† i â€“ 1 
    EndFor  
    return  b 
EndAlgorithm  B.  
Algorithm rearanjare(a, n):  
    i â† n  
    For p â† 2, n, 2 execute  
        b[p] â† a[i]  
        i â† i â€“ 1 
        b[p - 1] â† a[i]  
        i â† i â€“ 1 
    EndFor  
    If n MOD 2 = 1 then  
        b[n] â† a[i]  
    EndIf  
    return  b 
EndAlgorithm  
C.  
Algorithm rearanjare(a, n):  
    i â† n  
    For p â† 2, n, 2 execute  
        b[p] â† a[i]  
        i â† i â€“ 1 
    EndFor  
    i â† 1  
    For p â† 1, n, 2 execute  
        b[p] â† a[i]  
        i â† i + 1  
    EndFor  
    return  b 
EndAlgorithm  D.  
Algorithm rearanjare(a, n):  
    i â† n  
    For p â† 2, n, 3 execute  
        b[p] â† a[i]  
        i â† i â€“ 1 
        b[p - 1] â† a[i]  
        i â† i â€“ 1 
        If p + 1 â‰¤ n then    
            b[p + 1] â† a[i]  
            i â† i â€“ 1 
        EndIf  
    EndFor  
    If n MOD 3 = 1 then  
        b[n] â† a[i]  
    EndIf  
    return b 
EndAlgorithm  
 
29. Se considerÄƒ algoritmul f(n, p1, p2) , unde n, p1 È™i p2 sunt numere naturale strict pozitive 
(1 < n, p1, p2 â‰¤ 104 la momentul apelului).  
Algorithm f(n, p1, p2):  
    c â† 0  
    While p1 â‰¤ n execute   
        c â† c + n DIV p1  
        p1 â† p1 * p2  
    EndWhile  
    return c  
EndAlgorithm  
 
PrecizaÈ›i care dintre urmÄƒtoarele afirmaÈ›ii sunt adevÄƒrate:  
 
A. DacÄƒ cei trei parametri au valori egale ( n = p1 = p2), atunci algoritmul returneazÄƒ Ã®ntotdeauna 
valoarea 1.  
B. DacÄƒ p1 = 5 È™i p2 = 5, algoritmul returneazÄƒ numÄƒrul de cifre de 0 pe care le are n ! la sfÃ¢rÈ™it.  
C. DacÄƒ p1 È™i p2 au valori egale È™i mai mari decÃ¢t 2, atunci algoritmul returneazÄƒ [log p1 n]. 
D. Niciuna dintre celelalte trei afirmaÈ›ii nu este adevÄƒratÄƒ.  
 30. Care dintre urmÄƒtorii algoritmi returneazÄƒ numÄƒrul de numere sumative  din intervalul [ a, b] 
(0 < a < b < 10
6)? Un numÄƒr natural nenul n este sumativ  dacÄƒ n2 se poate scrie ca sumÄƒ a n numere 
naturale nenule consecutive. De exemplu, 1 È™i 7 sunt sumative  deoarece 1 = 1, respectiv 49 = 4 + 5 + 6 
+ 7 + 8 + 9 + 10.  11 
 A.  
Algorithm sumative(a, b):  
    k â† 0  
    For i â† a, b execute   
        If i MOD 2 â‰  0 then  
            k â† k + 1  
        EndIf  
    EndFor   
    return k   
EndAlgorithm  B.  
Algorithm sumative(a, b):  
    return (b - a) DIV 2 + (b - a) MOD 2  
+ (a MOD 2 + b MOD 2) DIV 2  
EndAlgorithm  
 
C.  
Algorithm sumative(a, b):  
  k â† 0  
  For i â† a, b execute  
    i2 â† i * i  
    For j â† 2, i â€“  1 execute  
      If i2 = j * i + (i * (i + 1) DIV 2) then  
        k â† k + 1  
      EndIf  
    EndFor   
  EndFor  
  return k   
EndAlgorithm  D.  
Algorithm sumative(a, b):  
  k â† 0  
  For i â† a, b execute  
    i2 â† i * i  
    For j â† 2, i DIV 2 execute  
      If i2 = j * i + (i * (i + 1) DIV 2) then  
        k â† k + 1  
      EndIf  
    EndFor   
  EndFor  
  return k 
EndAlgorithm  
UNIVERSITATEA BABEÈ˜-BOLYAI CLUJ-NAPOCA FACULTATEA DE MATEMATICÄ‚ È˜I INFORMATICÄ‚  
Concurs de Admitere 15 septembrie 2022  Proba scrisÄƒ la INFORMATICÄ‚ BAREM È˜I REZOLVARE OFICIU: 10 puncte 
1. AB 3 puncte 
2. AB 3 puncte 
3. AB 3 puncte 
4. C 3 puncte 
5. B 3 puncte 
6. AD 3 puncte 
7. C 3 puncte 
8. D 3 puncte 
9. D 3 puncte 
10. A 3 puncte 
11. A 3 puncte 
12. B 3 puncte 
13. AC 3 puncte 
14. ACD 3 puncte 
15. D 3 puncte 
16. C 3 puncte 
17. BD 3 puncte 
18. B 3 puncte 
19. ABD 3 puncte 
20. BD 3 puncte 
21. BC 3 puncte 
22. D 3 puncte 
23. C 3 puncte 
24. BC 3 puncte 
25. D 3 puncte 
26. ACD 3 puncte 
27. AD 3 puncte 
28. ABC 3 puncte 
29. AB 3 puncte 
30. AB 3 puncte    
